from enum import Enum
from math import pi, atan, acos, cos

import numpy as np
from AOD.Material import *

from AOD.Unit import *


class Position(Enum):
    Inner = 0
    Outer = 1.
    Middle = 0.5


class ForceType(Enum):
    Dry = 0
    Wet = 1
    Buoyancy = 2


class Cylinder(object):
    _d = 0.6 * ureg['m']  # private diameter of the screw
    _l = 1.92 * ureg['m']  # private length of the screw

    def __init__(self, d=None, l=None, no_of_helices=1):
        """ Constructor """
        if d is not None:
            self._d = d
        if l is not None:
            self._l = l

    @property
    def d(self):
        """ Gets the diameter of the cylinder """
        return self._d

    @d.setter
    def d(self, value):
        """ Sets the diameter of the cylinder """
        self._d = value

    @property
    def l(self):
        """ Gets the length of the cylinder """
        return self._l

    @l.setter
    def l(self, value):
        """ Sets the length of the cylinder """
        self._l = value

    @property
    def r(self):
        """ Gets the radius of the cylinder"""
        return self._d / 2

    @property
    def O(self):
        """ Gets the circumfence of the cylinder"""
        return pi * self.d

    @property
    def V(self):
        """ Volume of the cylinder"""
        return 0.25 * pi * self.d ** 2 * self.l

    def buoyancy(self, layers, depth):
        """ Buoyancy force generated by the volume of air in the cylinder """
        F = self.V * (layers['Fluid'].rho - layers['Air'].rho) * g
        return F.to('N')

    @property
    def A_t(self):
        return pi / 4 * self.d ** 2

    def theta(self, depth):
        return np.arccos((self.r - depth) / self.r)

    def A_s(self, depth):
        """ Submerged cross-section area of the cylinder """
        theta = self.theta(depth)
        a_s = self.r ** 2 * (theta - np.sin(theta) * np.cos(theta))  # TODO check with Edwin why pi has to be removed
        a_s[depth >= self.d] = self.A_t
        return a_s

    def V_s(self, depth):
        """ Submerged volume of the cylinder """
        return self.A_s(depth=depth) * self.l

    def B_acc(self, depth):
        """ Returns the width' and d' for a square representing the submerged cylinder"""
        b = 2 * self.r * (1 - ((self.r-depth)/self.r)**2)**0.5
        b[depth >= self.r] = self.d
        d_acc = self.A_s(depth) / b
        d_acc = np.nan_to_num(d_acc)
        return [b, d_acc]


class Helix(object):
    """ Definition of the Helix"""
    _p = 0.478 * ureg['m']  # private pitch of the helix
    _h = 0.1 * ureg['m']  # private vane height
    _cylinder = None  # private cylinder definition

    def __init__(self, cylinder, p=None, h=None):
        if p is not None:
            self.p = p
        if h is not None:
            self.h = h
        self._cylinder = cylinder

    @property
    def p(self):
        return self._p

    @p.setter
    def p(self, value):
        self._p = value

    @property
    def h(self):
        return self._h

    @h.setter
    def h(self, value):
        self._h = value

    def d(self, pos: Position = Position.Outer):
        return self._cylinder.d + (2. * pos.value * self.h)

    def O(self, pos: Position = Position.Outer):
        return pi * self.d(pos=pos)

    def r(self, pos: Position = Position.Outer):
        return self.d(pos=pos) / 2

    def alpha(self, pos: Position = Position.Inner):
        return atan(self.p / self.O(pos)) * ureg['rad']

    @property
    def no_threads(self):
        return self._cylinder.l / self.p

    def l(self, pos: Position = Position.Outer):
        return self.no_threads * (self.p ** 2 + (self.d(pos) * pi) ** 2) ** 0.5

    @property
    def A(self):
        return self.l(pos=Position.Middle) * self.h


class Screw(object):
    """ Archimedes screw"""
    cylinder = Cylinder()
    Helices = []

    def __init__(self, d=None, l=None, no_of_helices=1):
        """ Constructor """
        if d is not None:
            self.cylinder._d = d
        if l is not None:
            self.cylinder._l = l
        self.no_helices = no_of_helices

    @property
    def no_helices(self):
        return len(self.Helices)

    @no_helices.setter
    def no_helices(self, value):
        self.Helices = [Helix(cylinder=self.cylinder) for h in range(value)]

    def buoyancy(self, layers, depth):
        """ Gets the buoyancy of the screw, corrected for the depth in the Soil """
        F = -g * (
            (layers['Air'].rho - layers['Fluid'].rho) * self.cylinder.V + (
                layers['Fluid'].rho - layers['Soil'].rho_ins) * self.cylinder.V_s(
                depth=depth))
        return F.to('N')

    @property
    def helix_A(self):
        """ Gets the total surface of the helix """
        A = 0. * ureg['m**2']
        for h in self.Helices:
            A += h.A
        return A

    @property
    def helix_no_Threads(self):
        """ Gets the total number of threads for the screw """
        thr = 0. * ureg['dimensionless']
        for h in self.Helices:
            thr + h.no_threads

    @property
    def r(self):
        """ Gets the main radius of the cylinder """
        return self.cylinder.r


class Bot(object):
    """ Representing the bot, consisting of n amount of screws, weight and buyoancy """
    Screws = []  # The different screws
    buoyancy = 0. * ureg['N']  # Buoyancy of the bot (with out the screws)
    _weight_dry = 5.1e3 * ureg['kg']  # private weight of the bot
    _depth = 0. * ureg['m']  # private depth of the bot, taken at the bottom of the cylinders
    _v = 0.4 * ureg['m/s']  # private speed of the bot

    def __init__(self, no_of_screws=2):
        """ Constructor"""
        self.no_screw = no_of_screws

    @property
    def Screw(self):
        return self.Screws[0]

    @property
    def no_screw(self):
        return len(self.Screws)

    @no_screw.setter
    def no_screw(self, value):
        self.Screws = [Screw() for s in range(value)]

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, value):
        self._depth = value

    @property
    def weight_dry(self):
        return self._weight_dry

    @weight_dry.setter
    def weight_dry(self, value):
        self._weight_dry = value

    def F(self, forcetype: ForceType = ForceType.Dry, layers=None):
        force = 0. * ureg['N']
        if forcetype == ForceType.Dry:
            force = self.weight_dry * g
        elif forcetype == ForceType.Wet:
            force = self.F() - self.F(ForceType.Buoyancy, layers)
        elif forcetype == ForceType.Buoyancy:
            force = self.buoyancy
            for s in self.Screws:
                force += s.buoyancy(layers=layers, depth=self.depth)
        return force.to('N')
