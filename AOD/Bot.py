from enum import Enum
from math import pi, atan, acos, cos

import numpy as np
from AOD.Material import *

from AOD.Unit import *


class Position(Enum):
    Inner = 0
    Outer = 1.
    Middle = 0.5


class ForceType(Enum):
    Dry = 0
    Wet = 1
    Buoyancy = 2


class Friction(object):
    force = 0. * ureg['N']
    angle = 0. * ureg['rad']

    @property
    def x(self):
        return self.force * cos(self.angle)

    @property
    def y(self):
        return self.force * sin(self.angle)


class Cylinder(object):
    _d = 0.6 * ureg['m']  # private diameter of the screw
    _l = 1.92 * ureg['m']  # private length of the screw

    def __init__(self, d=None, l=None, no_of_helices=1):
        """ Constructor """
        if d is not None:
            self._d = d
        if l is not None:
            self._l = l

    @property
    def d(self):
        """ Gets the diameter of the cylinder """
        return self._d

    @d.setter
    def d(self, value):
        """ Sets the diameter of the cylinder """
        self._d = value

    @property
    def l(self):
        """ Gets the length of the cylinder """
        return self._l

    @l.setter
    def l(self, value):
        """ Sets the length of the cylinder """
        self._l = value

    @property
    def r(self):
        """ Gets the radius of the cylinder"""
        return self._d / 2

    @property
    def O(self):
        """ Gets the circumfence of the cylinder"""
        return pi * self.d

    @property
    def V(self):
        """ Volume of the cylinder"""
        return 0.25 * pi * self.d ** 2 * self.l

    def buoyancy(self, layers, depth):
        """ Buoyancy force generated by the volume of air in the cylinder """
        F = self.V * (layers['Fluid'].rho - layers['Air'].rho) * g
        return F.to('N')

    @property
    def A_t(self):
        return pi / 4 * self.d ** 2

    def theta(self, depth):
        x = (self.r - depth) / self.r
        t = np.arccos(x) * ureg['rad']
        return t

    def A_s(self, depth):
        """ Submerged cross-section area of the cylinder """
        theta = self.theta(depth).magnitude
        a_s = self.r ** 2 * (theta - np.sin(theta) * np.cos(theta))  # TODO check with Edwin why pi has to be removed
        a_s[depth >= self.d] = self.A_t
        return a_s

    def s(self, depth):
        """ Soil contact arc """
        theta = self.theta(depth)
        return theta * self.r

    def A_c(self, depth):
        """ Soil contact surface """
        return  self.s(depth) * self.l

    def V_s(self, depth):
        """ Submerged volume of the cylinder """
        return self.A_s(depth=depth) * self.l

    def B_acc(self, depth):
        """ Returns the width' and d' for a square representing the submerged cylinder"""
        x = (self.r - depth) / self.r
        b = 2 * self.r * (1 - (x) ** 2) ** 0.5
        b[depth >= self.r] = self.d
        d_acc = self.A_s(depth) / b
        d_acc = np.nan_to_num(d_acc)
        return [b, d_acc]

    def friction(self, force, helix, soil, depth):
        """ Frictional force on the cylinder due to contact with the soil 
        Returns the total force generated by the skin friction on the cylinder"""
        # TODO ask Rick why this is not a function of depth
        # TODO make function for moving screw
        f_fr = Friction()
        f_fr.angle = helix.alpha()
        if soil.c.magnitude == 0.:
            # RvdW method
            f_fr.force = force * soil.delta
        else:
            # RL method
            f_s = soil.alpha(weight=force * g, area=self.A_s(depth)) * soil.c
            f_fr.force = f_s * self.A_s(depth)
        f_fr.force.to('N')
        return f_fr

    def torque(self, force, helix, soil, depth):
        t_cyl = self.friction(force=force, helix=helix, soil=soil, depth=depth).force * self.r
        return t_cyl


class Helix(object):
    """ Definition of the Helix"""
    _p = 0.478 * ureg['m']  # private pitch of the helix
    _h = 0.1 * ureg['m']  # private vane height
    _cylinder = None  # private cylinder definition

    def __init__(self, cylinder, p=None, h=None):
        if p is not None:
            self.p = p
        if h is not None:
            self.h = h
        self._cylinder = cylinder

    @property
    def p(self):
        return self._p

    @p.setter
    def p(self, value):
        self._p = value

    @property
    def h(self):
        return self._h

    @h.setter
    def h(self, value):
        self._h = value

    def d(self, pos: Position = Position.Outer):
        return self._cylinder.d + (2. * pos.value * self.h)

    def O(self, pos: Position = Position.Outer):
        return pi * self.d(pos=pos)

    def r(self, pos: Position = Position.Outer):
        return self.d(pos=pos) / 2

    def alpha(self, pos: Position = Position.Inner):
        return atan(self.p / self.O(pos)) * ureg['rad']

    @property
    def no_threads(self):
        return self._cylinder.l / self.p

    def l(self, pos: Position = Position.Outer):
        return self.no_threads * (self.p ** 2 + (self.d(pos) * pi) ** 2) ** 0.5

    @property
    def A(self):
        return self.l(pos=Position.Middle) * self.h

    def theta(self, depth):
        x = (self.r() - depth) / self.r()
        t = np.arccos(x) * ureg['rad']
        return t

    def A_s(self, depth):
        """ Submerged area of the helix, Simplified by approaching it
         as a number of cirlces that are place n times on the cylinder """
        depth += self.h
        theta = self.theta(depth).magnitude
        a_s = self.r() ** 2 * (theta - np.sin(theta) * np.cos(theta))  # TODO check with Edwin why pi has to be removed
        a_s *= self.no_threads
        a_s[depth >= self.d()] = self.A
        a_s *= 2  # TODO check if area needs to be multiplied by two, two-sides of a vane
        return a_s

    def friction(self, load, depth, soil):
        """ Frictional force generated by the vanes"""
        fr_h = Friction()
        fr_h.force = soil.sigma_h(load) * self.A_s(depth) * soil.delta
        fr_h.angle = self.alpha(Position.Middle)
        return fr_h

    def torque(self, load, depth, soil):
        t_h = self.friction(load=load, depth=depth, soil=soil).x * self.r(Position.Middle)
        return t_h


class Screw(object):
    """ Archimedes screw"""
    cylinder = Cylinder()
    Helices = []

    def __init__(self, d=None, l=None, no_of_helices=1):
        """ Constructor """
        if d is not None:
            self.cylinder._d = d
        if l is not None:
            self.cylinder._l = l
        self.no_helices = no_of_helices

    @property
    def no_helices(self):
        return len(self.Helices)

    @no_helices.setter
    def no_helices(self, value):
        self.Helices = [Helix(cylinder=self.cylinder) for h in range(value)]

    def buoyancy(self, layers, depth):
        """ Gets the buoyancy of the screw, corrected for the depth in the Soil """
        F = -g * (
            (layers['Air'].rho - layers['Fluid'].rho) * self.cylinder.V + (
                layers['Fluid'].rho - layers['Soil'].rho_ins) * self.cylinder.V_s(
                depth=depth))
        return F.to('N')

    @property
    def helix_A(self):
        """ Gets the total surface of the helix """
        A = 0. * ureg['m**2']
        for h in self.Helices:
            A += h.A
        return A

    @property
    def helix_no_Threads(self):
        """ Gets the total number of threads for the screw """
        thr = 0. * ureg['dimensionless']
        for h in self.Helices:
            thr + h.no_threads

    @property
    def r(self):
        """ Gets the main radius of the cylinder """
        return self.cylinder.r

    @property
    def helix(self):
        return self.Helices[0]

    def torque(self, force, load, depth, soil):
        t_s = self.cylinder.torque(force=force, helix=self.helix,
                                   soil=soil, depth=depth)  # Torque as a result from friction against the cylinder
        for h in self.Helices:
            t_s += h.torque(load=load, depth=depth, soil=soil)  # Torque due to each helix
        return t_s.to('N*m')


class Bot(object):
    """ Representing the bot, consisting of n amount of screws, weight and buyoancy """
    Screws = []  # The different screws
    buoyancy = 0. * ureg['N']  # Buoyancy of the bot (with out the screws)
    _weight_dry = 5.1e3 * ureg['kg']  # private weight of the bot
    _depth = 0. * ureg['m']  # private depth of the bot, taken at the bottom of the cylinders
    _v = 0.4 * ureg['m/s']  # private speed of the bot

    def __init__(self, no_of_screws=2):
        """ Constructor"""
        self.no_screw = no_of_screws

    @property
    def Screw(self):
        return self.Screws[0]

    @property
    def no_screw(self):
        return len(self.Screws)

    @no_screw.setter
    def no_screw(self, value):
        self.Screws = [Screw() for s in range(value)]

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, value):
        self._depth = value

    @property
    def weight_dry(self):
        return self._weight_dry

    @weight_dry.setter
    def weight_dry(self, value):
        self._weight_dry = value

    def F(self, forcetype: ForceType = ForceType.Dry, layers=None):
        force = 0. * ureg['N']
        if forcetype == ForceType.Dry:
            force = self.weight_dry * g
        elif forcetype == ForceType.Wet:
            force = self.F() - self.F(ForceType.Buoyancy, layers)
        elif forcetype == ForceType.Buoyancy:
            force = self.buoyancy
            for s in self.Screws:
                force += s.buoyancy(layers=layers, depth=self.depth)
        return force.to('N')

    def torque(self, load, layers, depth=None):
        if depth is None:
            depth = self.depth
        t_b = 0. * ureg['N*m']
        for s in self.Screws:
            f = self.F(ForceType.Wet, layers=layers) / self.no_screw
            t_b += s.torque(force=f, load=load, depth=depth, soil=layers['Soil'])
        return t_b
